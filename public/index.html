<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Backtesting without Trasaction Costs and Taxes</title>
  <!-- Primary Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
  
  <!-- Fallback to local copy if CDN fails -->
  <script>
    function loadChartJS() {
      if (typeof Chart === 'undefined') {
        console.log('Loading local Chart.js fallback');
        const script = document.createElement('script');
        script.src = 'chart.min.js';
        script.onerror = function() {
          document.getElementById('chartError').textContent = 'Failed to load Chart library. Please check your internet connection.';
        };
        document.head.appendChild(script);
      }
    }
    // Verify immediately and every second for 5 seconds
    loadChartJS();
    const checkInterval = setInterval(loadChartJS, 1000);
    setTimeout(() => clearInterval(checkInterval), 5000);
  </script>
  <style>
    :root {
      --primary-color: #4361ee;
      --secondary-color: #3a0ca3;
      --accent-color: #f72585;
      --text-color: #2b2d42;
      --bg-color: #f8f9fa;
      --card-bg: #ffffff;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: var(--bg-color);
      color: var(--text-color);
    }
    
    h1 {
      color: var(--secondary-color);
      text-align: center;
      margin-bottom: 30px;
    }
    
    .input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
    }
    
    input {
      padding: 10px 15px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      flex-grow: 1;
    }
    
    button {
      padding: 10px 20px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: var(--secondary-color);
    }
    
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    
    .chart-container {
      margin-top: 30px;
      background-color: var(--card-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      position: relative;
      height: 60vh;
      min-height: 500px;
    }
    
    @media (max-width: 768px) {
      .chart-container {
        height: 50vh;
        min-height: 400px;
      }
    }
    
    #chartError {
      color: #d90429;
      margin-top: 15px;
      padding: 10px;
      background-color: #ffd6d6;
      border-radius: 4px;
    }
    
    select {
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
  </style>
</head>
<body>
  <h1>Backtesting without Trasaction Costs and Taxes</h1>
  <div>
    <select id="symbolInput">
      <option value="">Select S&P 500 Stock</option>
      <!-- Top 20 S&P 500 stocks by market cap -->
      <option value="AAPL">Apple (AAPL)</option>
      <option value="MSFT">Microsoft (MSFT)</option>
      <option value="AMZN">Amazon (AMZN)</option>
      <option value="NVDA">NVIDIA (NVDA)</option>
      <option value="GOOGL">Alphabet (GOOGL)</option>
      <option value="META">Meta (META)</option>
      <option value="TSLA">Tesla (TSLA)</option>
      <option value="BRK.B">Berkshire Hathaway (BRK.B)</option>
      <option value="JPM">JPMorgan Chase (JPM)</option>
      <option value="V">Visa (V)</option>
      <option value="JNJ">Johnson & Johnson (JNJ)</option>
      <option value="WMT">Walmart (WMT)</option>
      <option value="PG">Procter & Gamble (PG)</option>
      <option value="MA">Mastercard (MA)</option>
      <option value="HD">Home Depot (HD)</option>
      <option value="CVX">Chevron (CVX)</option>
      <option value="LLY">Eli Lilly (LLY)</option>
      <option value="AVGO">Broadcom (AVGO)</option>
      <option value="PEP">PepsiCo (PEP)</option>
      <option value="COST">Costco (COST)</option>
    </select>
    <button id="fetchBtn">Get Stock Data</button>
  </div>
  <div style="margin-top: 15px;">
    <label for="dateRange">Date Range: </label>
    <select id="dateRange">
      <option value="30">Last 30 Days</option>
      <option value="90">Last 90 Days</option>
      <option value="180">Last 6 Months</option>
      <option value="365">Last Year</option>
    </select>
  </div>
  
  <div id="crossoverSection" style="margin-top: 30px; display: none;">
    <h2>Crossover Analysis</h2>
    <div id="backtestPanel" style="margin-top: 20px; border: 1px solid #ddd; border-radius: 8px; padding: 15px; background-color: #f8f9fa;">
      <h3>Backtest Results ($100,000 Initial Capital)</h3>
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-top: 15px;">
        <div>
          <h4>Crossover Strategy</h4>
          <p>Initial Capital: <span id="initialCapital">$100,000.00</span></p>
          <p>Final Value: <span id="finalValue">$0.00</span></p>
          <p>Total Return: <span id="totalReturn">0.00%</span></p>
          <p>Total Trades: <span id="totalTrades">0</span></p>
          <p>Accumulated Profit: <span id="accumulatedProfit">$0.00</span></p>
        </div>
        <div>
          <h4>Buy & Hold</h4>
          <p>Initial Capital: <span id="buyHoldInitial">$100,000.00</span></p>
          <p>Final Value: <span id="buyHoldFinal">$0.00</span></p>
          <p>Total Return: <span id="buyHoldReturn">0.00%</span></p>
          <p>Shares Held: <span id="buyHoldShares">0</span></p>
        </div>
        <div>
          <h4>Trade History</h4>
          <div id="tradeLog" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background-color: white;"></div>
        </div>
      </div>
    </div>
    <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-top: 15px;">
      <table id="crossoverMatrix" style="width: 100%; border-collapse: collapse;">
        <thead>
          <tr style="background-color: #f5f5f5;">
            <th style="padding: 10px; text-align: left;">Date</th>
            <th style="padding: 10px; text-align: right;">Price</th>
            <th style="padding: 10px; text-align: right;">5-Day SMA</th>
            <th style="padding: 10px; text-align: right;">20-Day SMA</th>
            <th style="padding: 10px; text-align: right;">Difference</th>
            <th style="padding: 10px; text-align: center;">Cross Type</th>
          </tr>
        </thead>
        <tbody id="crossoverBody"></tbody>
      </table>
    </div>
    <div style="display: flex; gap: 20px; margin-top: 20px;">
      <div style="flex: 1; border: 1px solid #ddd; border-radius: 8px; padding: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
        <h3 style="margin-top: 0;">Golden Cross Points</h3>
        <ul id="goldenCrossList" style="max-height: 200px; overflow-y: auto; padding-left: 20px;"></ul>
      </div>
      <div style="flex: 1; border: 1px solid #ddd; border-radius: 8px; padding: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
        <h3 style="margin-top: 0;">Death Cross Points</h3>
        <ul id="deathCrossList" style="max-height: 200px; overflow-y: auto; padding-left: 20px;"></ul>
      </div>
    </div>
  </div>

  <div class="chart-container">
    <canvas id="stockChart"></canvas>
    <p id="chartError" style="color: red; margin-top: 10px;"></p>
    <p id="rateLimitInfo" style="color: #666; font-size: 0.9em; margin-top: 5px;"></p>
  </div>


  <script>
    const priceCtx = document.getElementById('stockChart').getContext('2d');
    let stockChart;

    // Cache stock data in localStorage
    function getCachedStockData(symbol) {
      const cached = localStorage.getItem(`stockData_${symbol}`);
      return cached ? JSON.parse(cached) : null;
    }

    function cacheStockData(symbol, data) {
      localStorage.setItem(`stockData_${symbol}`, JSON.stringify({
        data,
        timestamp: new Date().getTime()
      }));
    }

    function isCacheValid(cachedData, maxAgeHours = 48) {
      if (!cachedData || !cachedData.timestamp) return false;
      const ageHours = (new Date().getTime() - cachedData.timestamp) / (1000 * 60 * 60);
      return ageHours < maxAgeHours;
    }

    document.getElementById('fetchBtn').addEventListener('click', async () => {
      const symbol = document.getElementById('symbolInput').value;
      if (!symbol) return alert('Please select a stock from the list');
      
      try {
        // Show loading state
        const btn = document.getElementById('fetchBtn');
        btn.disabled = true;
        btn.textContent = 'Loading...';

        // Check cache first - exit early if valid cache exists
        const cachedData = getCachedStockData(symbol);
        if (cachedData && isCacheValid(cachedData)) {
          console.log('Using cached data for:', symbol);
          updateChart(cachedData.data);
          document.getElementById('chartError').textContent = '';
          document.getElementById('rateLimitInfo').textContent = 'Using cached data (last updated: ' + 
            new Date(cachedData.timestamp).toLocaleString() + ')';
          document.getElementById('rateLimitInfo').style.color = '#28a745';
          btn.disabled = false;
          btn.textContent = 'Get Stock Data';
          return;
        }

        // Only proceed to API call if no valid cache
        console.log('No valid cache - fetching fresh data for:', symbol);
        const response = await fetch(`/api/stock/${symbol}`);
        if (!response.ok) {
          if (response.status === 429 || response.status === 400) {
            throw new Error('API limit reached (5 requests/minute max). Please wait 1 minute before trying again.');
          }
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Show rate limit info
        const remaining = response.headers.get('X-RateLimit-Remaining');
        const reset = response.headers.get('X-RateLimit-Reset');
        if (remaining && reset) {
          const resetTime = new Date(parseInt(reset) * 1000);
          console.log(`API calls remaining: ${remaining}, resets at: ${resetTime.toLocaleTimeString()}`);
          document.getElementById('rateLimitInfo').textContent = 
            `API calls left: ${remaining} (resets at ${resetTime.toLocaleTimeString()})`;
        }

        // Add delay to prevent rapid consecutive requests
        await new Promise(resolve => setTimeout(resolve, 15000));
        
        const responseText = await response.text();
        console.log('Raw API response text:', responseText);
        
        let result;
        try {
          result = JSON.parse(responseText);
        } catch (error) {
          console.error('Failed to parse JSON:', error);
          throw new Error('Invalid JSON response from server');
        }
        
        console.log('Parsed API response:', result);
        
        // Validate response structure
        if (!result || typeof result !== 'object') {
          throw new Error('Invalid API response format');
        }
        
        const data = result.data || result;
        console.log('Processing data:', data);
        
        // Validate required fields
        if (!data.symbol || typeof data.symbol !== 'string') {
          throw new Error('Missing or invalid symbol in response');
        }
        
        if (!data.closingPrices || !Array.isArray(data.closingPrices)) {
          console.error('Invalid closingPrices:', data.closingPrices);
          throw new Error('Missing or invalid closingPrices array');
        }
        
        // Validate each price point
        const invalidPrices = data.closingPrices.filter(price => 
          !price || typeof price.date !== 'string' || isNaN(price.close)
        );
        
        if (invalidPrices.length > 0) {
          console.error('Invalid price points:', invalidPrices.slice(0, 3));
          throw new Error(`Found ${invalidPrices.length} invalid price points`);
        }
        
        console.log('Data validation passed');
        
        if (!data || !data.closingPrices || !Array.isArray(data.closingPrices)) {
          console.error('Invalid data structure - closingPrices:', data?.closingPrices);
          throw new Error(data?.error || 'Invalid data format from server');
        }

        if (!data.symbol || typeof data.symbol !== 'string') {
          console.error('Invalid symbol in response:', data?.symbol);
          throw new Error('Invalid symbol in response');
        }

        // Validate closing prices structure
        const invalidItems = data.closingPrices.filter(item => 
          !item.date || !item.close || isNaN(item.close)
        );
        if (invalidItems.length > 0) {
          console.error('Invalid price data items:', invalidItems.slice(0, 3));
          throw new Error(`Found ${invalidItems.length} invalid data points`);
        }

        console.log('API response:', data);
        if (!data.closingPrices || !Array.isArray(data.closingPrices)) {
          throw new Error('Invalid data format: missing closingPrices array');
        }
        updateChart(data);
        cacheStockData(symbol, data);
        document.getElementById('chartError').textContent = '';
      } catch (error) {
        console.error('Error:', error);
        document.getElementById('chartError').textContent = error.message;
        if (stockChart) {
          stockChart.destroy();
          stockChart = null;
        }
      } finally {
        const btn = document.getElementById('fetchBtn');
        btn.disabled = false;
        btn.textContent = 'Get Stock Data';
      }
    });

    // Define all crossover analysis functions first
    function analyzeCrossovers(prices, dates, sma5, sma20) {
      // Backtesting variables
      const initialCapital = 100000;
      let capital = initialCapital;
      let shares = 0;
      let position = 0; // 0 = out, 1 = in
      const trades = [];
      let accumulatedProfit = 0;
      
      // Buy & Hold variables
      let buyHoldShares = 0;
      let buyHoldInitialPrice = 0;
      
      // Update backtest panel
      function updateBacktestPanel() {
        // Update crossover strategy stats
        document.getElementById('initialCapital').textContent = `$${initialCapital.toFixed(2)}`;
        const finalValue = position === 1 ? shares * prices[prices.length-1] : capital;
        document.getElementById('finalValue').textContent = `$${finalValue.toFixed(2)}`;
        document.getElementById('totalReturn').textContent = `${((finalValue - initialCapital) / initialCapital * 100).toFixed(2)}%`;
        document.getElementById('totalTrades').textContent = trades.length;
        document.getElementById('accumulatedProfit').textContent = `$${accumulatedProfit.toFixed(2)}`;
        
        // Update buy & hold stats
        if (buyHoldShares === 0 && prices.length > 0) {
          buyHoldShares = initialCapital / prices[0];
          buyHoldInitialPrice = prices[0];
        }
        const buyHoldFinal = buyHoldShares * prices[prices.length-1];
        document.getElementById('buyHoldInitial').textContent = `$${initialCapital.toFixed(2)}`;
        document.getElementById('buyHoldFinal').textContent = `$${buyHoldFinal.toFixed(2)}`;
        document.getElementById('buyHoldReturn').textContent = `${((buyHoldFinal - initialCapital) / initialCapital * 100).toFixed(2)}%`;
        document.getElementById('buyHoldShares').textContent = buyHoldShares.toFixed(2);
        
        // Update trade log
        const tradeLog = document.getElementById('tradeLog');
        tradeLog.innerHTML = trades.map(trade => `
          <div style="margin-bottom: 5px; padding: 5px; border-bottom: 1px solid #eee;">
            <strong>${trade.date}</strong>: ${trade.type.toUpperCase()} at $${trade.price.toFixed(2)}
            ${trade.type === 'sell' ? `<br>Profit: $${trade.profit.toFixed(2)}` : ''}
          </div>
        `).join('');
      }

      const crossoverData = [];
      const goldenCrosses = [];
      const deathCrosses = [];
      
      const minLength = Math.min(sma5.length, sma20.length);
      for (let i = 0; i < minLength; i++) {
        const sma5Val = sma5[i]?.value ?? sma5[i];
        const sma20Val = sma20[i]?.value ?? sma20[i];
        
        if (typeof sma5Val !== 'number' || typeof sma20Val !== 'number') continue;

        const diff = sma5Val - sma20Val;
        const price = prices[i + 19];
        
        const crossoverPoint = {
          date: sma5[i].date,
          price: price,
          sma5: sma5Val,
          sma20: sma20Val,
          diff: diff,
          type: null
        };

        if (i > 0) {
          const prevDiff = sma5[i-1].value - sma20[i-1].value;
          if (prevDiff < 0 && diff > 0) {
            crossoverPoint.type = 'golden';
            goldenCrosses.push(crossoverPoint);
            if (position === 0) {
              // Buy signal
              shares = capital / price;
              capital = 0;
              position = 1;
              trades.push({
                date: crossoverPoint.date,
                type: 'buy',
                price: price,
                shares: shares,
                profit: 0
              });
              updateBacktestPanel();
            }
          } else if (prevDiff > 0 && diff < 0) {
            crossoverPoint.type = 'death';
            deathCrosses.push(crossoverPoint);
            if (position === 1) {
              // Sell signal
              const profit = (shares * price) - (shares * trades[trades.length-1].price);
              capital = shares * price;
              shares = 0;
              position = 0;
              trades.push({
                date: crossoverPoint.date,
                type: 'sell',
                price: price,
                shares: shares,
                profit: profit
              });
              accumulatedProfit += profit;
              updateBacktestPanel();
            }
          }
        }
        crossoverData.push(crossoverPoint);
      }
      return { crossoverData, goldenCrosses, deathCrosses };
    }

    function displayCrossoverAnalysis(data) {
      const crossoverBody = document.getElementById('crossoverBody');
      const goldenCrossList = document.getElementById('goldenCrossList');
      const deathCrossList = document.getElementById('deathCrossList');
      
      crossoverBody.innerHTML = '';
      goldenCrossList.innerHTML = '';
      deathCrossList.innerHTML = '';
      
      data.crossoverData.forEach(point => {
        const row = document.createElement('tr');
        row.style.borderBottom = '1px solid #eee';
        
        const cells = [
          point.date,
          `$${point.price.toFixed(2)}`,
          `$${point.sma5.toFixed(2)}`,
          `$${point.sma20.toFixed(2)}`,
          point.diff.toFixed(4),
          point.type ? 
            `<span style="color: ${point.type === 'golden' ? 'green' : 'red'}; font-weight: bold;">
              ${point.type === 'golden' ? 'Golden Cross' : 'Death Cross'}
            </span>` : ''
        ];
        
        cells.forEach((text, i) => {
          const cell = document.createElement('td');
          cell.style.padding = '8px';
          cell.style.textAlign = i === 0 ? 'left' : 'right';
          if (i === 5) cell.style.textAlign = 'center';
          cell.innerHTML = text;
          row.appendChild(cell);
        });
        crossoverBody.appendChild(row);
      });
      
      data.goldenCrosses.forEach(cross => {
        const item = document.createElement('li');
        item.innerHTML = `
          <strong>${cross.date}</strong>: 
          5-Day SMA ($${cross.sma5.toFixed(2)}) crossed above 20-Day SMA ($${cross.sma20.toFixed(2)})
        `;
        goldenCrossList.appendChild(item);
      });
      
      data.deathCrosses.forEach(cross => {
        const item = document.createElement('li');
        item.innerHTML = `
          <strong>${cross.date}</strong>: 
          5-Day SMA ($${cross.sma5.toFixed(2)}) crossed below 20-Day SMA ($${cross.sma20.toFixed(2)})
        `;
        deathCrossList.appendChild(item);
      });
      
      document.getElementById('crossoverSection').style.display = 'block';
    }

    function markCrossPointsOnChart(chart, goldenCrosses, deathCrosses) {
      // Remove existing crossover markers
      chart.data.datasets = chart.data.datasets.filter(ds => 
        ds.label !== 'Golden Cross' && ds.label !== 'Death Cross'
      );

      // Calculate exact crossover points by interpolation
      const goldenCrossPoints = goldenCrosses.map(cross => {
        const index = chart.data.labels.indexOf(cross.date);
        if (index === -1) return null;
        
        // Get the SMA values at crossover
        const sma5 = cross.sma5;
        const sma20 = cross.sma20;
        
        // Calculate exact price at crossover (average of SMAs)
        const crossoverPrice = (sma5 + sma20) / 2;
        
        return {
          x: cross.date,
          y: crossoverPrice,
          point: cross
        };
      }).filter(Boolean);

      const deathCrossPoints = deathCrosses.map(cross => {
        const index = chart.data.labels.indexOf(cross.date);
        if (index === -1) return null;
        
        const sma5 = cross.sma5;
        const sma20 = cross.sma20;
        const crossoverPrice = (sma5 + sma20) / 2;
        
        return {
          x: cross.date,
          y: crossoverPrice,
          point: cross
        };
      }).filter(Boolean);

      // Add golden cross markers
      chart.data.datasets.push({
        label: 'Golden Cross',
        data: goldenCrossPoints,
        backgroundColor: 'rgba(0, 128, 0, 0.8)',
        borderColor: 'rgba(0, 128, 0, 0.8)',
        pointBackgroundColor: 'rgba(0, 128, 0, 0.8)',
        pointBorderColor: '#fff',
        pointRadius: 8,
        pointHoverRadius: 12,
        pointStyle: 'crossRot',
        borderWidth: 2,
        showLine: false,
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const point = ctx.raw.point;
              return [
                `Golden Cross on ${point.date}`,
                `Price: $${point.price.toFixed(2)}`,
                `5-Day SMA: $${point.sma5.toFixed(2)}`,
                `20-Day SMA: $${point.sma20.toFixed(2)}`,
                `Difference: ${point.diff.toFixed(4)}`
              ];
            }
          }
        }
      });

      // Add death cross markers
      chart.data.datasets.push({
        label: 'Death Cross',
        data: deathCrossPoints,
        backgroundColor: 'rgba(200, 0, 0, 0.8)',
        borderColor: 'rgba(200, 0, 0, 0.8)',
        pointBackgroundColor: 'rgba(200, 0, 0, 0.8)',
        pointBorderColor: '#fff',
        pointRadius: 8,
        pointHoverRadius: 12,
        pointStyle: 'crossRot',
        borderWidth: 2,
        showLine: false,
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const point = ctx.raw.point;
              return [
                `Death Cross on ${point.date}`,
                `Price: $${point.price.toFixed(2)}`,
                `5-Day SMA: $${point.sma5.toFixed(2)}`,
                `20-Day SMA: $${point.sma20.toFixed(2)}`,
                `Difference: ${point.diff.toFixed(4)}`
              ];
            }
          }
        }
      });

      chart.update();
    }

    function calculateSMA(prices, dates, windowSize = 20) {
      const sma = [];
      for (let i = windowSize - 1; i < prices.length; i++) {
        const sum = prices.slice(i - windowSize + 1, i + 1).reduce((a, b) => a + b, 0);
        sma.push({ date: dates[i], value: sum / windowSize });
      }
      return sma;
    }



    function markCrossPointsOnChart(chart, goldenCrosses, deathCrosses) {
      // First remove any existing crossover markers
      chart.data.datasets = chart.data.datasets.filter(ds => 
        ds.label !== 'Golden Cross' && ds.label !== 'Death Cross'
      );

      // Create golden crosses dataset
      const goldenCrossData = Array(chart.data.labels.length).fill(null);
      goldenCrosses.forEach(cross => {
        const index = chart.data.labels.indexOf(cross.date);
        if (index !== -1) {
          goldenCrossData[index] = cross.price;
        }
      });
      
      // Create death crosses dataset
      const deathCrossData = Array(chart.data.labels.length).fill(null);
      deathCrosses.forEach(cross => {
        const index = chart.data.labels.indexOf(cross.date);
        if (index !== -1) {
          deathCrossData[index] = cross.price;
        }
      });
      
      // Add cross-shaped markers with tooltips
      const goldenCrossDataset = {
        label: 'Golden Cross',
        data: goldenCrossData,
        backgroundColor: 'rgb(0, 128, 0)',
        borderColor: 'rgb(0, 128, 0)',
        pointBackgroundColor: 'rgb(0, 128, 0)',
        pointBorderColor: 'rgb(0, 128, 0)',
        pointRadius: 8,
        pointHoverRadius: 10,
        pointStyle: 'crossRot',
        borderWidth: 2,
        showLine: false,
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const point = goldenCrosses.find(p => p.date === chart.data.labels[ctx.dataIndex]);
              return point ? [
                `Golden Cross on ${point.date}`,
                `Price: $${point.price.toFixed(2)}`,
                `5-Day SMA: $${point.sma5.toFixed(2)}`,
                `20-Day SMA: $${point.sma20.toFixed(2)}`
              ] : [];
            }
          }
        }
      };

      const deathCrossDataset = {
        label: 'Death Cross',
        data: deathCrossData,
        backgroundColor: 'rgb(200, 0, 0)',
        borderColor: 'rgb(200, 0, 0)',
        pointBackgroundColor: 'rgb(200, 0, 0)',
        pointBorderColor: 'rgb(200, 0, 0)',
        pointRadius: 8,
        pointHoverRadius: 10,
        pointStyle: 'crossRot',
        borderWidth: 2,
        showLine: false,
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const point = deathCrosses.find(p => p.date === chart.data.labels[ctx.dataIndex]);
              return point ? [
                `Death Cross on ${point.date}`,
                `Price: $${point.price.toFixed(2)}`,
                `5-Day SMA: $${point.sma5.toFixed(2)}`,
                `20-Day SMA: $${point.sma20.toFixed(2)}`
              ] : [];
            }
          }
        }
      };

      // Add the new datasets
      chart.data.datasets.push(goldenCrossDataset, deathCrossDataset);
      chart.update();
    }

    function updateChart(data) {
      if (typeof Chart === 'undefined') {
        document.getElementById('chartError').textContent = 'Chart library not loaded - trying again...';
        loadChartJS();
        return;
      }
      
      console.log('Chart data received:', JSON.stringify(data, null, 2));
      
      try {
        // Verify data structure
        if (!data || !data.closingPrices || !Array.isArray(data.closingPrices)) {
          throw new Error('Invalid chart data format - missing closingPrices array');
        }

        // Validate price data
        const validPrices = data.closingPrices.filter(item => 
          item && item.date && !isNaN(item.close)
        );
        
        if (validPrices.length === 0) {
          throw new Error('No valid price data found');
        }

        // Get date range selection
        const dateRange = parseInt(document.getElementById('dateRange').value) || 90;
        const maxPoints = Math.min(250, validPrices.length);
        const chartData = dateRange > 0 
          ? validPrices.slice(-Math.min(dateRange, maxPoints))
          : validPrices.slice(-maxPoints);

        console.log(`Rendering ${chartData.length} valid data points`);
        console.log('Sample data:', chartData.slice(0, 3));
        
        const dates = chartData.map(item => item.date);
        const closes = chartData.map(item => item.close);

        // Clear previous chart
        if (stockChart) stockChart.destroy();

        // Create basic chart first
        stockChart = new Chart(priceCtx, {
          type: 'line',
          data: {
            labels: dates,
            datasets: [{
              label: `${data.symbol} Closing Price`,
              data: closes,
              borderColor: 'rgb(54, 162, 235)',
              tension: 0.1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                position: 'top',
                labels: {
                  font: {
                    size: 14,
                    family: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif"
                  },
                  padding: 20,
                  usePointStyle: true
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0,0,0,0.8)',
                titleFont: {
                  size: 16
                },
                bodyFont: {
                  size: 14
                },
                padding: 12,
                cornerRadius: 6
              }
            },
            scales: {
              x: {
                title: { 
                  display: true, 
                  text: 'Date',
                  font: {
                    size: 14,
                    weight: 'bold',
                    family: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif"
                  },
                  color: '#2b2d42'
                },
                grid: {
                  display: false,
                  drawBorder: true
                },
                ticks: {
                  font: {
                    size: 12
                  }
                }
              },
              y: {
                title: { 
                  display: true, 
                  text: 'Price ($)',
                  font: {
                    size: 14,
                    weight: 'bold',
                    family: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif"
                  },
                  color: '#2b2d42'
                },
                grid: {
                  color: 'rgba(0,0,0,0.05)',
                  drawBorder: true
                },
                ticks: {
                  font: {
                    size: 12
                  },
                  callback: function(value) {
                    return '$' + value.toFixed(2);
                  }
                }
              },

            },
            interaction: {
              mode: 'nearest',
              axis: 'x',
              intersect: false
            },
            elements: {
              point: {
                radius: 0,
                hoverRadius: 6
              },
              line: {
                borderWidth: 2,
                tension: 0.1
              }
            }
          }
        });

        // Add technical indicators
        const sma5 = calculateSMA(closes, dates, 5);
        const sma20 = calculateSMA(closes, dates, 20);
        
        // Update price chart with SMAs
        stockChart.data.datasets.push(
          {
            label: '20-Day SMA',
            data: [...Array(dates.length - sma20.length).fill(null), ...sma20.map(item => item.value)],
            borderColor: 'rgb(255, 99, 132)',
            tension: 0.1,
            borderDash: [5, 5]
          },
          {
            label: '5-Day SMA',
            data: [...Array(dates.length - sma5.length).fill(null), ...sma5.map(item => item.value)],
            borderColor: 'rgb(34, 139, 34)',
            tension: 0.1,
            borderDash: [5, 5]
          }
        );
        
        // Analyze and display crossovers
        const crossoverResults = analyzeCrossovers(closes, dates, sma5, sma20);
        displayCrossoverAnalysis(crossoverResults);
        markCrossPointsOnChart(stockChart, crossoverResults.goldenCrosses, crossoverResults.deathCrosses);
        
        stockChart.update();


      } catch (error) {
        console.error('Chart error:', error);
        document.getElementById('chartError').textContent = `Chart error: ${error.message}`;
      }
    }
  </script>
</body>
</html>